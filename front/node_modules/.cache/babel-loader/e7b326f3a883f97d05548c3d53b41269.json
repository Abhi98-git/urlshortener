{"ast":null,"code":"/**\n * header-row.tsx\n *\n * Forked from reactabular-table version 8.14.0\n * https://github.com/reactabular/reactabular/tree/v8.14.0/packages/reactabular-table/src\n */\nimport * as React from 'react';\nimport { evaluateFormatters } from './evaluate-formatters';\nimport { evaluateTransforms } from './evaluate-transforms';\nimport { mergeProps } from './merge-props';\nimport { HeaderCellInfoWrapper } from '../HeaderCellInfoWrapper';\nexport const HeaderRow = ({\n  rowData,\n  rowIndex,\n  renderers,\n  onRow = () => Object\n}) => React.createElement(renderers.row, onRow(rowData, {\n  rowIndex\n}), rowData.map((column, columnIndex) => {\n  const {\n    property,\n    header = {},\n    props = {}\n  } = column;\n  const evaluatedProperty = property || header && header.property;\n  const {\n    label,\n    transforms = [],\n    formatters = [],\n    info = {}\n  } = header;\n  const extraParameters = {\n    columnIndex,\n    property: evaluatedProperty,\n    column\n  };\n  const transformedProps = evaluateTransforms(transforms, label, extraParameters);\n\n  if (!transformedProps) {\n    // tslint:disable-next-line:no-console\n    console.warn('Table.Header - Failed to receive a transformed result'); // eslint-disable-line max-len, no-console\n  }\n\n  let cellNode;\n  const {\n    tooltip,\n    tooltipProps,\n    popover,\n    popoverProps,\n    ariaLabel,\n    className\n  } = info; // consumer can specify header cell tooltip/popover in two ways, but the transforms approach is preferred,\n  // especially for sorting tables that use `transforms: [sortable]`\n  // {\n  //   title: 'Repositories',\n  //   header: {\n  //     info: {\n  //       tooltip: 'More information about repositories',\n  //       className: 'repositories-info-tip',\n  //       tooltipProps: {\n  //         isContentLeftAligned: true\n  //       }\n  //     }\n  //   }\n  // }\n  //\n  // {\n  //   title: 'Repositories',\n  //   transforms: [\n  //     info({\n  //       tooltip: 'More information about repositories',\n  //       className: 'repositories-info-tip',\n  //       tooltipProps: {\n  //         isContentLeftAligned: true\n  //       }\n  //     }),\n  //     sortable\n  //   ]\n  // },\n\n  if (tooltip) {\n    cellNode = React.createElement(HeaderCellInfoWrapper, {\n      variant: \"tooltip\",\n      info: tooltip,\n      tooltipProps: tooltipProps,\n      ariaLabel: ariaLabel,\n      className: className\n    }, transformedProps.children || evaluateFormatters(formatters)(label, extraParameters));\n  } else if (popover) {\n    cellNode = React.createElement(HeaderCellInfoWrapper, {\n      variant: \"popover\",\n      info: popover,\n      popoverProps: popoverProps,\n      ariaLabel: ariaLabel,\n      className: className\n    }, transformedProps.children || evaluateFormatters(formatters)(label, extraParameters));\n  } else {\n    cellNode = transformedProps.children || evaluateFormatters(formatters)(label, extraParameters);\n  }\n\n  return React.createElement(renderers.cell, Object.assign({\n    key: `${columnIndex}-header`\n  }, mergeProps(props, header && header.props, transformedProps)), cellNode);\n}));\nHeaderRow.displayName = 'HeaderRow';","map":{"version":3,"sources":["../../../../../src/components/Table/base/header-row.tsx"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * header-row.tsx\n *\n * Forked from reactabular-table version 8.14.0\n * https://github.com/reactabular/reactabular/tree/v8.14.0/packages/reactabular-table/src\n */\nimport * as React from 'react';\nimport { evaluateFormatters } from './evaluate-formatters';\nimport { evaluateTransforms } from './evaluate-transforms';\nimport { mergeProps } from './merge-props';\nimport { HeaderCellInfoWrapper } from '../HeaderCellInfoWrapper';\nexport const HeaderRow = ({ rowData, rowIndex, renderers, onRow = () => Object }) => React.createElement(renderers.row, onRow(rowData, { rowIndex }), rowData.map((column, columnIndex) => {\n    const { property, header = {}, props = {} } = column;\n    const evaluatedProperty = property || (header && header.property);\n    const { label, transforms = [], formatters = [], info = {} } = header;\n    const extraParameters = {\n        columnIndex,\n        property: evaluatedProperty,\n        column\n    };\n    const transformedProps = evaluateTransforms(transforms, label, extraParameters);\n    if (!transformedProps) {\n        // tslint:disable-next-line:no-console\n        console.warn('Table.Header - Failed to receive a transformed result'); // eslint-disable-line max-len, no-console\n    }\n    let cellNode;\n    const { tooltip, tooltipProps, popover, popoverProps, ariaLabel, className } = info;\n    // consumer can specify header cell tooltip/popover in two ways, but the transforms approach is preferred,\n    // especially for sorting tables that use `transforms: [sortable]`\n    // {\n    //   title: 'Repositories',\n    //   header: {\n    //     info: {\n    //       tooltip: 'More information about repositories',\n    //       className: 'repositories-info-tip',\n    //       tooltipProps: {\n    //         isContentLeftAligned: true\n    //       }\n    //     }\n    //   }\n    // }\n    //\n    // {\n    //   title: 'Repositories',\n    //   transforms: [\n    //     info({\n    //       tooltip: 'More information about repositories',\n    //       className: 'repositories-info-tip',\n    //       tooltipProps: {\n    //         isContentLeftAligned: true\n    //       }\n    //     }),\n    //     sortable\n    //   ]\n    // },\n    if (tooltip) {\n        cellNode = (React.createElement(HeaderCellInfoWrapper, { variant: \"tooltip\", info: tooltip, tooltipProps: tooltipProps, ariaLabel: ariaLabel, className: className }, transformedProps.children || evaluateFormatters(formatters)(label, extraParameters)));\n    }\n    else if (popover) {\n        cellNode = (React.createElement(HeaderCellInfoWrapper, { variant: \"popover\", info: popover, popoverProps: popoverProps, ariaLabel: ariaLabel, className: className }, transformedProps.children || evaluateFormatters(formatters)(label, extraParameters)));\n    }\n    else {\n        cellNode = transformedProps.children || evaluateFormatters(formatters)(label, extraParameters);\n    }\n    return React.createElement(renderers.cell, Object.assign({ key: `${columnIndex}-header` }, mergeProps(props, header && header.props, transformedProps)), cellNode);\n}));\nHeaderRow.displayName = 'HeaderRow';\n//# sourceMappingURL=header-row.js.map"]},"metadata":{},"sourceType":"module"}